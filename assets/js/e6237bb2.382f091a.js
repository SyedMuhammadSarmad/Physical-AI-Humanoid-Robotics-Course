"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[1116],{8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var i=t(6540);const r={},o=i.createContext(r);function a(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(o.Provider,{value:n},e.children)}},8527:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"part3/chapter8","title":"Chapter 8: Robot Kinematics","description":"Robot kinematics is the study of the motion of robots without considering the forces that cause it. It is one of the most fundamental topics in robotics, as it provides the basis for understanding and controlling the movement of robots.","source":"@site/docs/part3/chapter8.md","sourceDirName":"part3","slug":"/part3/chapter8","permalink":"/Physical-AI-Humanoid-Robotics-Course/docs/part3/chapter8","draft":false,"unlisted":false,"editUrl":"https://github.com/SyedMuhammadSarmad/Physical-AI-Humanoid-Robotics-Course/tree/main/docs/docs/part3/chapter8.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 7: Neural Networks for Robotic Control","permalink":"/Physical-AI-Humanoid-Robotics-Course/docs/part2/chapter7"},"next":{"title":"Chapter 9: Robot Dynamics","permalink":"/Physical-AI-Humanoid-Robotics-Course/docs/part3/chapter9"}}');var r=t(4848),o=t(8453);const a={sidebar_position:1},s="Chapter 8: Robot Kinematics",c={},h=[{value:"Forward Kinematics",id:"forward-kinematics",level:2},{value:"Denavit-Hartenberg (D-H) Parameters",id:"denavit-hartenberg-d-h-parameters",level:3},{value:"Inverse Kinematics",id:"inverse-kinematics",level:2},{value:"Code Example: Forward Kinematics with the D-H Convention",id:"code-example-forward-kinematics-with-the-d-h-convention",level:3},{value:"References",id:"references",level:3}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"chapter-8-robot-kinematics",children:"Chapter 8: Robot Kinematics"})}),"\n",(0,r.jsx)(n.p,{children:"Robot kinematics is the study of the motion of robots without considering the forces that cause it. It is one of the most fundamental topics in robotics, as it provides the basis for understanding and controlling the movement of robots."}),"\n",(0,r.jsx)(n.h2,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,r.jsx)(n.p,{children:"Forward kinematics is the problem of finding the position and orientation of the end-effector of a robot given the values of its joint parameters. For a serial manipulator, the joint parameters are the angles of the revolute joints and the displacements of the prismatic joints."}),"\n",(0,r.jsxs)(n.p,{children:["The most common method for solving the forward kinematics problem is the ",(0,r.jsx)(n.strong,{children:"Denavit-Hartenberg (D-H) convention"}),". The D-H convention is a systematic method for assigning coordinate frames to the links of a serial manipulator and for deriving the transformation matrices between adjacent links."]}),"\n",(0,r.jsx)(n.h3,{id:"denavit-hartenberg-d-h-parameters",children:"Denavit-Hartenberg (D-H) Parameters"}),"\n",(0,r.jsx)(n.p,{children:"The D-H convention uses four parameters to describe the transformation between two adjacent coordinate frames:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"a_i"}),": link length"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"\u03b1_i"}),": link twist"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"d_i"}),": link offset"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"\u03b8_i"}),": joint angle"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,r.jsx)(n.p,{children:"Inverse kinematics is the problem of finding the values of the joint parameters that will place the end-effector of a robot at a desired position and orientation. This is a much more difficult problem than forward kinematics, as it is a non-linear problem that can have multiple solutions."}),"\n",(0,r.jsx)(n.p,{children:"There are two main approaches to solving the inverse kinematics problem:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Analytical Solutions"}),": For some simple robots, it is possible to derive a closed-form analytical solution to the inverse kinematics problem."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Numerical Solutions"}),": For more complex robots, it is necessary to use numerical methods to solve the inverse kinematics problem. These methods are iterative and can be computationally expensive."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"code-example-forward-kinematics-with-the-d-h-convention",children:"Code Example: Forward Kinematics with the D-H Convention"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import numpy as np\r\n\r\ndef dh_transform(a, alpha, d, theta):\r\n    """\r\n    Calculates the D-H transformation matrix.\r\n    """\r\n    return np.array([\r\n        [np.cos(theta), -np.sin(theta) * np.cos(alpha), np.sin(theta) * np.sin(alpha), a * np.cos(theta)],\r\n        [np.sin(theta), np.cos(theta) * np.cos(alpha), -np.cos(theta) * np.sin(alpha), a * np.sin(theta)],\r\n        [0, np.sin(alpha), np.cos(alpha), d],\r\n        [0, 0, 0, 1]\r\n    ])\r\n\r\n# D-H parameters for a simple 2-DOF robot\r\ndh_params = [\r\n    [0.5, 0, 0, 0],\r\n    [0.5, 0, 0, 0]\r\n]\r\n\r\n# Joint angles\r\ntheta1 = np.pi / 4\r\ntheta2 = np.pi / 4\r\n\r\n# Transformation matrices\r\nT1 = dh_transform(dh_params[0][0], dh_params[0][1], dh_params[0][2], theta1)\r\nT2 = dh_transform(dh_params[1][0], dh_params[1][1], dh_params[1][2], theta2)\r\n\r\n# Final transformation\r\nT_final = np.dot(T1, T2)\r\n\r\n# End-effector position\r\nx = T_final[0, 3]\r\ny = T_final[1, 3]\r\n\r\nprint(f"End-effector position: ({x}, {y})")\n'})}),"\n",(0,r.jsx)(n.h3,{id:"references",children:"References"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://vertexaisearch.cloud.google.com/grounding-api-redirect/AUZIYQFhvsgz3pt2Um_eZ7xcLFeR9Q3DQ-wPGys6DZ8sy6XI_eBewZ9PGO-f1Gif8sPGhDWvH7KIuEgiGlLktH9Gf8-H2ksbT1B3nbjirI5C2p-8gp-Gcm0D9UqFL176xiIuRK6xvxYO0V07uMY3ieEpR0Q4NaUzXwsPpoEoAreAVQ==",children:"ResearchGate - A Review of Robot Kinematics"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://vertexaisearch.cloud.google.com/grounding-api-redirect/AUZIYQFKn8wx9CHHi3P7TuN2vpQb-PfcrEkMSZemUOWp3206DrtUDKuAIdEKQNqvfUA_Zu6D2DZ9Fn1RXlY8NjZZdYfVHdWg3FmYm9OKdq7BDfwLTx55z0_jNHINofFiYqzAlBg9Ow==",children:"MDPI - Data-Driven Forward Kinematics Estimation"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);